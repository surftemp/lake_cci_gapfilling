--- a/src/processors/preprocessor/lswt_processing/dineof_cv.py
+++ b/src/processors/preprocessor/lswt_processing/dineof_cv.py
@@ -313,7 +313,7 @@ class DineofCVGenerationStep(ProcessingStep):
     def apply(self, ds: xr.Dataset, config: ProcessingConfig) -> xr.Dataset:
         try:
             if not config.cv_mask_var:
                 raise ValueError("cv_enable is set but cv_mask_var is not provided.")
 
             data_var = config.cv_data_var or "lake_surface_water_temperature"
             mask_var = config.cv_mask_var
@@ -329,30 +329,110 @@ class DineofCVGenerationStep(ProcessingStep):
             S = ds[data_var].load()
             mask_da = ds[mask_var].load()
 
             mask = mask_da.astype("float64").values
             sea = np.isfinite(mask) & (mask > 0)
 
             M = int(sea.sum())
             print(f"[CV] Sea pixels (M): {M}")
 
+            # --- NEW: target fraction logic (closest from below) ---
+            cv_fraction_target = float(getattr(config, "cv_fraction_target", 1.0))
+            cv_absolute_cap    = getattr(config, "cv_absolute_cap", None)
+
+            # Build strict-valid pool using same RAW/CF semantics as generator's strict filter
+            tmp_path = None
+            try:
+                backing_path, tmp_path = _ensure_prepared_path(S.to_dataset(name=S.name), S.name, getattr(config, "output_file", None))
+                ds_cf  = xr.open_dataset(backing_path, decode_times=False, mask_and_scale=True)
+                ds_raw = xr.open_dataset(backing_path, decode_times=False, mask_and_scale=False)
+
+                A_cf  = ds_cf[S.name].values  # (T,lat,lon)
+                A_raw = ds_raw[S.name].values
+                T = A_cf.shape[0]
+
+                fill_vec = _collect_fill_values(ds_raw[S.name])
+                SEA = np.broadcast_to(sea[None, :, :], (T,)+sea.shape)
+
+                valid_cf = np.isfinite(A_cf)
+                valid_cf_tm1 = np.vstack([np.zeros((1,)+sea.shape, dtype=bool), valid_cf[:-1]])
+                valid = SEA & valid_cf & valid_cf_tm1
+
+                if fill_vec.size:
+                    raw = A_raw.astype(np.float64)
+                    eq_fill_t = np.any(np.isclose(raw[..., None], fill_vec[None, None, None, :], rtol=0, atol=1e-12), axis=-1)
+                    eq_fill_tm1 = np.vstack([np.zeros((1,)+sea.shape, dtype=bool), eq_fill_t[:-1]])
+                    valid &= ~eq_fill_t & ~eq_fill_tm1
+
+                valid[0, :, :] = False  # need t-1
+                valid_pool_size = int(valid.sum())
+            finally:
+                try:
+                    ds_cf.close(); ds_raw.close()
+                except Exception:
+                    pass
+                if tmp_path and os.path.exists(tmp_path):
+                    try: os.remove(tmp_path)
+                    except Exception: pass
+
+            K_target = int(np.floor(cv_fraction_target * valid_pool_size))
+            if cv_absolute_cap is not None:
+                K_target = min(K_target, int(cv_absolute_cap))
+            K_target = max(0, K_target)
+
             core = DineofCVGeneratorCore()
-            pairs, meta = core.generate(
-                S,
-                sea,
-                nbclean=nbclean,
-                seed=seed,
-                prepared_file_path=getattr(config, "output_file", None),
-            )
+            nbclean0 = nbclean
+            nbclean_max = max(nbclean0, (int(S.sizes["time"]) - 1))
+            best_pairs = None; best_meta = None; best_k = -1
+
+            for nb in range(nbclean0, nbclean_max + 1):
+                pairs_nb, meta_nb = core.generate(
+                    S, sea, nbclean=nb, seed=seed, prepared_file_path=getattr(config, "output_file", None)
+                )
+                k = int(pairs_nb.shape[0])
+                if k == K_target:
+                    best_pairs, best_meta, best_k = pairs_nb, meta_nb, k
+                    break
+                if k < K_target and k > best_k:
+                    best_pairs, best_meta, best_k = pairs_nb, meta_nb, k
+                if k > K_target:
+                    if best_pairs is None:
+                        # first try already exceeds -> downsample to exact target
+                        rng = np.random.default_rng(seed)
+                        take = rng.choice(k, size=K_target, replace=False)
+                        best_pairs = pairs_nb[take, :]
+                        best_meta = meta_nb
+                        best_k = K_target
+                    break
+            else:
+                # never exceeded even at nbclean_max; use best-under (or last)
+                if best_pairs is None:
+                    best_pairs, best_meta, best_k = pairs_nb, meta_nb, int(pairs_nb.shape[0])
+
+            pairs, meta = best_pairs, best_meta
 
             if pairs.size:
                 max_m = int(pairs[:, 0].max())
                 if max_m > M:
                     raise ValueError(f"CV pairs produced m={max_m} but only {M} sea pixels exist.")
 
+            # provenance of the cap/target
+            meta["cv_fraction_target"] = float(cv_fraction_target)
+            meta["cv_absolute_cap"] = (None if cv_absolute_cap is None else int(cv_absolute_cap))
+            meta["total_cv_points"] = int(pairs.shape[0])
+
             path, vname = core.save_pairs_netcdf(pairs, out_nc, varname=varname)
 
             ds.attrs["dineof_cv_path"] = path
             ds.attrs["dineof_cv_var"] = vname
             ds.attrs["dineof_cv_total_points"] = meta["total_cv_points"]
             ds.attrs["dineof_cv_affected_frames"] = meta["affected_frames"]
             ds.attrs["dineof_cv_M_ocean_pixels"] = M
             ds.attrs["dineof_cv_T_frames"] = int(S.sizes["time"])
+            ds.attrs["dineof_cv_fraction_target"] = float(cv_fraction_target)
+            if cv_absolute_cap is not None:
+                ds.attrs["dineof_cv_absolute_cap"] = int(cv_absolute_cap)
 
             print(f"[CV] Saved: {path}#{vname} ({meta['total_cv_points']} pts)")
             print(f"[CV] Spatial order: {meta['spatial_order']}")
             print(f"[CV] kept t: {meta['cv_keep_t']}, kept (t+1): {meta['cv_shift_t_plus_1']}, dropped: {meta['cv_dropped']}")
+            print(f"[CV] Target: {K_target}, achieved: {meta['total_cv_points']}")
             print(f"[CV] Add to dineof.init: clouds = '{path}#{vname}'")
             return ds